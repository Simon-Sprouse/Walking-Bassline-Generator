@page "/"
@using BlazorWalkingBassline.Models
@using BlazorWalkingBassline.MusicTheory

@inject IJSRuntime JS

<PageTitle>Walking Basslines</PageTitle>

<h1>Walking Bassline Generator</h1>

<h2>Progression</h2>
<p>Key: @progression.Key</p>
<p>Chords: @string.Join(", ", progression.Chords)</p>


<h2>Generated Notes</h2>
@foreach (Note note in progression.Notes) 
{ 
    <p>@note @generator.NoteFromMidi(note.MidiNumber)</p>
}

@* <h2>Generated Chord Notes (Midi Number)</h2>
@foreach (var pair in chordNotesList)
{
    <p>@pair.chord: @string.Join(", ", pair.notes)</p>
}

<h2>Generated Chord Names (Midi Number)</h2>
@foreach (var pair in chordNotesList)
{
    <p>@pair.chord: @string.Join(", ", pair.notes.Select(m => generator.NoteFromMidi(m)))</p>
}

<h2>ASCII Bass Tab Prototype</h2>

<pre>@TabFormatter.RenderAscii(tabNotesList)</pre>


<h2>Test JS Interop</h2>
<button @onclick="RunTest">Run JS Test</button>
<button @onclick="StartAudio">Start Audio</button>
<button @onclick="PlayTone">Play Note</button>

<h2>Audio File Generation</h2>
<button @onclick="GenerateAudioFile">Generate Audio File</button>
<button @onclick="PlayGeneratedAudio">Play Generated Audio</button>
<button @onclick="PauseAudio">Pause Audio</button>
<button @onclick="StopAudio">Stop Audio</button> *@

@code {

    private Progression progression;
    private IProgressionGenerator generator;
    @* private List<(Chord chord, List<int> notes)> chordNotesList;

    private List<(Chord chord, List<TabNote>)> tabNotesList; *@

    protected override void OnInitialized()
    {

        // Initialize generator
        int[] formula = { 1, 3, 5, 3 };
        generator = new Generator(formula);

        // Initialize progression
        double beat = 1; // TODO make dynamic (right now we assume every chord starts on first beat)
        double duration = 4; // TODO later make this dynamic
        string key = "G";
        List<Chord> chords = new List<Chord>
            {
                new Chord(ScaleDegree.One, ChordQuality.Major, 1, beat, duration),
                new Chord(ScaleDegree.Five, ChordQuality.Major, 2, beat, duration),
                new Chord(ScaleDegree.Two, ChordQuality.Minor, 3, beat, duration),
                new Chord(ScaleDegree.Four, ChordQuality.Major, 4, beat, duration)
            };

        progression = new Progression(key, chords, generator);







        

        @* // Generate chord notes
        Console.WriteLine("Generating Chords");
        chordNotesList = generator.GenerateChordNotes();



        // Map generated chord MIDI notes to TabNotes using the greedy fretboard mapper
        tabNotesList = FretboardMapper.MapChordsToTab(chordNotesList); *@

    }


    private async Task RunTest() 
    {
        await JS.InvokeVoidAsync("testJS");
    }


    private bool audioStarted = false;

    private async Task StartAudio()
    {
        await JS.InvokeVoidAsync("toneInterop.startAudio");
        audioStarted = true;
    }

    private async Task PlayTone()
    {
        if (!audioStarted)
        {
            Console.WriteLine("⚠️ Please start audio first!");
            return;
        }

        await JS.InvokeVoidAsync("toneInterop.playNote", "C3", "8n");
    }

    private async Task GenerateAudioFile()
    {
        await JS.InvokeVoidAsync("toneInterop.generateAudioFile");
    }

    private async Task PlayGeneratedAudio()
    {
        await JS.InvokeVoidAsync("toneInterop.playGeneratedAudio");
    }
    
    private async Task StopAudio() 
    {
        // resets playhead
        await JS.InvokeVoidAsync("toneInterop.stopAudio");
    }

    private async Task PauseAudio() 
    { 
        await JS.InvokeVoidAsync("toneInterop.pauseAudio");
    }


}
